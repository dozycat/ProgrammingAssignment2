q()
x <- c(4, TRUE)
x
x <- c(1,3, 5)
y <- c(3, 2, 10)
rbind(x, y)
x <- 1:4
y <- 2
x + y
x <- c(17, 14, 4, 5, 13, 12, 10)
x[x > 10] <- 4
x
data<-read.csv("D:\Data\hw1_data.csv")
data<-read.csv("D:\\Data\\hw1_data.csv")
data
data[Qzone>90]
data.frame(data,Qzone>90)
data(1,2)
data
data(Qone>31)
data[Qzone>31]
data["Qzone">31]
x <- c(4, TRUE)
x
x <- c(1,3, 5)
y <- c(3, 2, 10)
rbind(x, y)
x <- c(4, TRUE)
x
class(x_
class(x)
class(x)
x <- c(1,3, 5)
y <- c(3, 2, 10)
cbind(x, y)
x <- 1:4
y <- 2:3
x+y
class(x+y)
q()
ls
fusd()
library(datasets)
data(iris)
iris$Sepal.Length
mean(iris$Sepal.Length)
iris
apply(iris,2,mean)
apply(iris[,1:4],2,mean)
split(iris,iris$Species)
spply(split(iris,iris$Species),2,mean)
sapply(split(iris,iris$Species),2,mean)
sapply(split(iris,iris$Species),mean)
sapply(split(iris,iris$Species)[,1:4],mean)
sapply(split(iris$Sepal.Length,iris$Species),mean)
a = matrix(1:12,nrow=4,ncol=3)
t(A)
t(a)
solve(a)
a = matrix(1:16,nrow=4,ncol=4)
solve(a)
a = matrix(norm(16),nrow=4,ncol=4)
a = matrix(norm(1:16),nrow=4,ncol=4)
a = matrix(norm(0),nrow=4,ncol=4)
norm(0)
norm(0,0)
norm(0,0)
setwd("D:/workplace/ProgrammingAssignment2")
source("cachematrix.R")
a = matrix(runif(16,min=0,max=1),nrow=4,ncol=4)
a
solve(a)
a*solve(a)
cacheSolve(a)
source("cachematrix.R")
cacheSolve(a)
source("cachematrix.R")
cacheSolve(a)
b = makeCacheMatrix(b)
cacheSolve(b)
cacheSolve()
cacheSolve(A)
cacheSolve(a)
cacheSolve(b)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function solves for a matrix's inverse if it hasn't been cached previously.
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(b)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function solves for a matrix's inverse if it hasn't been cached previously.
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(b)
source("cachematrix.R")
a
b <- makeCacheMatrix(a)
b
cacheSolve(b)
cacheSolve(b)
source("cachematrix.R")
a
b = makeCacheMatrix(a)
b
cacheSolve(b)
cacheSolve(b)
